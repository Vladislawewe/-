.ORIG x3000    

LD  R2, INIT    ; Загружаем начальное значение счетчика в R2 (0)
LEA  R1, NUMBERS  ; Загружаем адрес массива NUMBERS в R1

LOOP_READ     ; Цикл считывания чисел

 ADD  R2, R2, #1  ; Увеличиваем счетчик R2 на 1
 LEA R0, STRING  ; Загружаем адрес строки "Enter a number: " в R0
 PUTS       ; Выводим строку на консоль
 GETC       ; Считываем символ с клавиатуры
 OUT        ; Выводим считанный символ на консоль

 ADD  R3, R0, #0  ; Копируем символ в R3
 LD  R4, NEG48   ; Загружаем константу -48 в R4 (для конвертации ASCII в число)
 ADD  R3, R3, R4  ; Преобразуем символ из ASCII в число (вычитаем 48)
 STR  R3, R1, #0  ; Сохраняем число в массив NUMBERS по адресу R1
 ADD  R1, R1, #1  ; Увеличиваем адрес в R1 для записи следующего числа

 LEA  R0, NEWLINE  ; Загружаем адрес строки новой строки в R0
 PUTS       ; Выводим новую строку

 ADD  R3, R2, #-5 ; Проверяем, не достигнут ли лимит ввода (5 чисел)
 BRz  SORT     ; Если достигнут, переходим к сортировке
 BRnzp  LOOP_READ ; Иначе продолжаем ввод

SORT        ; Алгоритм сортировки (Bubble Sort)

 LD  R6, COUNT   ; Загружаем размер массива (5) в R6
 ADD  R4, R6, #0  ; Копируем размер в R4

OUTLOOP       ; Внешний цикл сортировки

 ADD  R4, R4, #-1  ; Уменьшаем счетчик R4 на 1
 BRz  OUTPUT_LOOP ; Если R4 равен 0, переходим к выводу отсортированного массива
 LEA  R3, NUMBERS  ; Загружаем адрес начала массива в R3
 ADD  R5, R4, #0  ; Копируем счетчик в R5

INLOOP       ; Внутренний цикл сортировки

 LDR  R0, R3, #0  ; Загружаем элемент массива по адресу R3 в R0
 LDR  R1, R3, #1  ; Загружаем следующий элемент массива по адресу R3+1 в R1
 NOT  R2, R1    ; Инвертируем значение R1 (для сравнения)
 ADD  R2, R2, #1   ; Дополняем до отрицательного значения
 ADD  R2, R0, R2  ; Вычисляем разность R0 - R1
 BRN  SWAP     ; Если разность отрицательная, переходим к обмену
 SKIP_SWAP     ; Если разность неотрицательная, пропускаем обмен
 ADD  R3, R3, #1  ; Увеличиваем адрес R3 для следующего элемента массива
 ADD  R5, R5, #-1  ; Уменьшаем счетчик R5 на 1
 BRp  INLOOP    ; Если R5 больше 0, переходим к следующему элементу массива
 BRnzp  OUTLOOP   ; Если R5 равен 0, переходим к следующему шагу внешнего цикла

SWAP        ; Обмен элементов массива

 STR  R1, R3, #0  ; Сохраняем значение R1 в R3
SKIP_SWAP   ; Если разность неотрицательная, пропускаем обмен

 ADD R3, R3, #1 ; Увеличиваем адрес R3 для следующего элемента массива
 ADD R5, R5, #-1 ; Уменьшаем счетчик R5 на 1
 BRp INLOOP  ; Если R5 больше 0, переходим к следующему элементу массива
 BRnzp OUTLOOP  ; Если R5 равен 0, переходим к следующему шагу внешнего цикла

OUTPUT_LOOP ; Цикл вывода отсортированного массива

 LEA R1, NUMBERS ; Загружаем адрес начала массива в R1
 LD R2, INIT  ; Загружаем начальное значение счетчика в R2 (0)

LOOP_PRINT  ; Цикл вывода каждого элемента массива

 LDR R0, R1, #0 ; Загружаем элемент массива по адресу R1 в R0
 LD R4, POS48  ; Загружаем константу 48 в R4 (для конвертации числа в ASCII)
 ADD R0, R0, R4 ; Преобразуем число в ASCII (прибавляем 48)
 OUT    ; Выводим символ на консоль
 LEA R0, NEWLINE ; Загружаем адрес строки новой строки в R0
 PUTS    ; Выводим новую строку
 ADD R1, R1, #1 ; Увеличиваем адрес R1 для следующего элемента массива
 ADD R2, R2, #1 ; Увеличиваем счетчик R2 на 1
 ADD R3, R2, #-5 ; Проверяем, не достигнут ли лимит вывода (5 элементов)
 BRz END   ; Если достигнут, переходим к завершению программы
 BRnzp LOOP_PRINT ; Иначе продолжаем вывод

END    ; Завершение программы

HALT    ; Останавливаем выполнение программы

INIT .FILL #0   ; Определение начального значения счетчика (0)
STRING .STRINGZ "Enter a number: " ; Определение строки "Enter a number: "
NEWLINE .STRINGZ "\n" ; Определение строки новой строки
POS48 .FILL #48  ; Определение константы 48 (для конвертации числа в ASCII)
NEG48 .FILL #-48  ; Определение константы -48 (для конвертации ASCII в число)
NUMBERS .BLKW #5  ; Определение массива NUMBERS размером 5
COUNT .FILL #5   ; Определение размера массива (5)

.END    ; Конец программы
